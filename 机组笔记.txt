第二章：运算方法和运算器
要理解运算器结构，前提是知道运算方法，
要明白运算方法，前提是认识数据
数据分为：数值型数据和非数值型数据
数值型数据：从小数点位置是否固定分为
定点数   浮点数
定点数：小数点位置固定
如小数点定在最低位右边：整数
如小数点定在最高位左边：纯小数
整数的表示：
从是否带符号分为：无符号整数和有符号整数
无符号整数：不带符号位
会算它的值
比如：用3位表示一个无符号数
最小---最大值：000----111（0---7）
4位：0000---1111（0----15）
n位：n个0-----n个1（0-----2n-1）
有符号数：带+-，要用一位表示符号（0表示+  1表示-）
比如：用3位表示一个有符号数
范围：1 11-----0 11  （-3  ------   +3）
      -3 -2 -1 -0 +0 +1 +2 +3
4位带符号数：1111------0111（-7   ---   +7）
n位带带符号数：1 1...1 ----- 0 1...1
                -（2n-1-1）----+（ 2n-1-1） 
8位表示：-37  1 0100101
例题：4位表示有符号数
-3:   1 011
+1:   0 001
求：（-3）+（+1）=？（应该-2）
1011         -3
0001   +     +1
1100         -4  错了
在运算器（加法器）定点数不能用原码表示
改为用补码表示：

如何表示：原码  反码  补码
原码：将有符号定点数直接转为二进制的形式
      4位表示    -3原码：1011
                 +1原码：0001
反码：对负数：原码的符号位不变，数值位取反
      对正数：和原码相同
4位表示    -3反码：1100
                 +1反码：0001
补码：对负数：反码 最低位+1
      对正数：和原码相同
4位表示    -3补码：1101
                 +1补码：0001
用补码算：-3+1（-2）
1101
0001   +
1110（补码，它是？的补码，它的原码为？）
反推：1101（反码）  
反推：1010（原码）-2
用补码运算正确
定点数用补码表示

关于—0: 以3位为例
           -3   -2   -1    -0  +0  +1  +2  +3
原码范围：111  110  101  100  000 001 010 011
反码范围：100  101  110  111  000 001 010 011





补码范围：100  101  110  111  000 001 010 011
？表示-4
所以3位带符号数的补码范围：-4----+3
推广：4位带符号数的补码范围：-8----+7
推广：n位带符号数的补码范围：
     -2n-1-----+（2n-1-1）     

浮点数：小数点位置不固定的数
如：0.0000314   3.14   31.4
如：0.00001011    101.1    10.11
小数点位置不定，如何确定值？
不表示 .  ，上述三个数都变成：1011
如何解决？
想办法将小数点位置固定下来。采用指数形式表示。
如：0.0000314=0.314*10-4
31.4=0.314*10+2
0.00001011 =0.1011*2-100
   101.1=0.1011*2+11
  上述表示形式，尾数一样（定点数纯小数），通过指数（阶）调整大小。
即：浮点数用定点数表示（尾数：纯小数，阶：整数）


如能分别存放浮点数的4个要素，就等于保存了一个浮点数。
哪4要素：+0.0000101111101 =+0.101111101*2100
数符（+） 尾数（1011）   阶符（-）  阶（100）
0 101111101 1 100
各部分特性是统一的标准：ieee 754标准
分析32位754标准：
数符占1位  尾数占23位  阶占8位
754标准浮点数由3各部分组成，阶符没了？
关于阶和阶符：
为了比较阶的大小和对阶操作方便（速度快），要想办法去符号（没有负数）。
例题：求 0.36123*103+0.78965*105  =？
不能直接尾数求和，因为阶不一样
所以要先看两个阶是否一样（比较阶的大小），
如阶不一样，要对阶（把阶弄成一样）
0.0036123*105+0.78965*105  
（小阶转大阶，尾数右移，丢弃低位，误差小）
或者
0.36123*103+78.965*103
（大阶转小阶，尾数左移，丢弃高位，误差大）
如阶带符号，比较大小或者对阶，都要运算符号位，速度慢。
如阶不带符号，速度快
如何去符号（不是直接删除符号）
达到两点：没有负数   ，   不能改变数的大小关系
方法：在原来阶的基础上，加上一个数
8位有符号数的范围：-127 ------  +127
要去符号：如加上127  0------254
            加上128  1------255
8位无符号数范围：0----255
到底选127还是128？
无穷大在运算时没有意义，不用表达无穷大。
32位浮点数，阶如为255时，表示无穷大。
所以选127 ！

关于ieee754的尾数：
占23位（精确到小数点后23位），想办法提高精度
由原来的0.M格式（纯小数，M23位，精度23位）
变为1.M格式（1是默认的，不予保存，只存M23位，精度24位）


754 标准32位格式：
数符1位 阶8位   尾数23位  

1 11111101  10010100000000000000000    

问：这个数是多少？
- 1.100101*211111101-01111111















今天：定点数运算方法
后天：定点加法器
定点数的加法规则：
[x+y]补 =x补+y补
定点数的减法规则：
[x-y]补 =x补+（-y）补
减法最终做的是加法，用加法器实现减法
例题：4位表示，求-4 + -2
-4的补码：1100
-2的补码：1110   +
结果：1010  （补码）  -6的补码
例题：4位表示，求4+5  （结果应该为+9）
0100  4的补码
0101  5的补码
1001  （错误，两个正数相加得到负数）
上述错误称为：溢出错误（超出了范围）
加法器要能检测是否产生了溢出错误
如何检测？两种方法




一种叫单符号位：
最高位产生的进位和符号位产生的进位不一致：溢出
                                   一致：未溢出
0***
0***  +
1（最高位产生进位1，符号位产生进位0）错误
0（最高位产生进位0，符号位产生进位0）正确
两个正数相加，如结果还是正的未溢出
                        负的溢出（错误）
1***
1***  +
0（最高位产生进位0，符号位产生进位1）错误
1（最高位产生进位1，符号位产生进位1）正确

0***
1***  +
不用分析，肯定不会溢出
（加法器采用）




双符号位判断溢出：
  用两位表示一个符号：00正
                      11负
两个数相加，如果出现：
两个符号位一致（00或11），未溢出，正确
两个符号位不一致（01或10），溢出，错误
00 ***
00 ***    +
00 *** 没问题
01 *** 有问题

11***
11***   +
11*** 没问题
10*** 有问题

认识了数据（定点数用补码表示）
运算方法有了
溢出检测方法有了

可以构造加法器（用门电路）
熟悉：与门  或门  异或门  和对应的运算规则
分析：-y补  和  y补    的关系
比如：8位表示  -87  和 +87 补码的关系 
-y补码=y补码全部取反 +1 

异或规则：相同为0
          不同为1
0异或0=0  1异或1=0
0异或1=1  1异或0=1

y=87=64+16+4+2+1
y补 =01010111    
-y补=10101001
-y补码=y补码全部取反 +1 
所以：[x-y]补=x补-y补=x补+（-y）补
           =x补+y补全部取反+1







加法器的设计：
在设计一个n位加法器之前，先设计一个一位的加法器
把两个一位数相加的所有情况都列出来：
0+0=0
0+1=1
1+0=1
1+1=0 进1
还要考虑低位过来的进位，再列出所有情况：
0+0+0=0 进0
0+0+1=1 进0
0+1+0=1 进0
0+1+1=0 进1
1+0+0=1 进0
1+0+1=0 进1
1+1+0=0 进1
1+1+1=1 进1    
共8种可能
上述八种运算，其实都有5个要素：
加数、被加数、低位来的进位 称为输入 （加法器）
和、向高位产生的进位       称为输出

要设计一个电路，能完成上述8种运算情况
对8种运算进行数学推导，得到公式：
Si＝Ai⊕Bi⊕Ci  （要做两次异或运算）
Ci＋1＝AiBi+(Ai⊕Bi)Ci（要做与、或、异或）
利用5个门电路可以实现上述公式
构造出的一位加法器，称为全加器（fa）
一个全加器可以实现一位数相加
4位加法器要4个全加器
n位加法器要有n个全加器
怎么用fa构造加法器？以4位为例：
用一个方框代表一个fa
该方框有3个输入，2个输出
4个fa不是独立的，而是有关联的
该关联通过进位建立：低位产生的进位给高位用
低位的进位输出 作为 高位的进位输入
溢出检测采用单符号位法：异或门
减法如何实现？
[x-y]补=x补-y补=x补+（-y）补
           =x补+y补全部取反+1
如何实现y补全部取反？
用非门？不用

用异或门：能实现非运算效果，而且可控的。
1（固定） 异或 0 : 1
1（固定） 异或 1:  0  起到了对另一端取反的效果

0（固定）异或0:0
0（固定）异或1:1   对另一端不改变

定点乘法运算和乘法器
乘法运算的符号怎么处理：
  把两个符号单独拿出来，不参加乘法运算，
  作异或：0和0  或者  1和1   异或：0
          0和1  或者  1和0   异或：1
乘法运算的数值处理：
先来看直接用原码相乘
例题：求  0.1101  *   0.1011

手工运算方法：
先求出每一位的部分积，然后部分积相加得到乘积
如乘法器采用手工算法实现：用加法器实现部分积的
                           相加
但是完全采用手工算法存在问题：

1: n位的加法器无法实现两个n位数相乘
n位乘法的乘积最多2n位
2: 部分积不是一次性相加的，要分步加，
   每次加之前要先移位，而移位操作是非常慢的，
   导致速度慢
如何解决：不用加法器实现部分积相加，改用
          全加器（fa）实现（实现两个一位数相加）
          3个输入、两个输出
要几个fa？这些fa如何排列？
设：A=0.a4a3a2a1a0
B=0.b4b3b2b1b0
求A*B

部分积由所有的ai*bj 构成
怎么得到ai*bj？表面看是乘运算
但是：发现 乘运算的结果 和 与运算结果一样
      1*1=1  1与1=1
      1*0=0  1与0=0
      0*1=0  0与1=0
      0*0=0  0与0=0
所以可以用与门得到所有的ai与bj，从值的角度
也就得到所有的ai*bj，即得到所有部分积
5位*5位要25个与门，可以得到所有的aibj
也就是得到所有的ai*bj
把aibj送乘法阵列：
谁的阵列？FA 全加器的阵列
要多少个FA？20个
这些fa如何排列？从上向下  往左偏

一个任务：设计一个3位*3位的乘法阵列

有符号的定点数，是用补码表示的，
可不可以直接用补码算？
4位表示，求-3  *   -2   （+6）
-3补码：1 101
-2补码：1 110
符号作异或：1异或1=0 （负负得正）
101*110=0（正）   11110（不是6，错误）
不能直接用补码乘
用原码乘
-3原码：1 011
-2原码：1 010
符号作异或：1异或1=0 （负负得正）
011*010=0（正）   000110=+6（正确）
用原码表示，加减法可能出错（要求用补码）
用补码表示，乘法可能出错（要用原码）
用补码表示定点数，乘法之前转为原码，
然后乘，乘完后将乘积（原码）转为补码
如何实现原码和补码的互转？
用求补电路（求补器）
原码和补码的关系：
对负数：
自右向左找到第一个1， 
该1及其右边的0 保持不变
左边的值取反
对正数：不变
验证：1（负）  1011000
      1        0101000








定点除法运算
人工除法算法：得到商和余数
比如：8除以3 商为2 余数为2
例题：求：0.1001除以0.1011
上述手工运算：发现
1:除法最后做的是减法（加法器）
2:根据被除数（或当前余数+0）和除数的
  大小关系，决定商上1还是上0
例题：0.1011 除以 0.1110
如果机器按照手工算法计算，存在问题：
1:机器（运算器）没有眼睛，无法看出谁大谁小
2:不能直接减，要移位（除数右移）。速度慢
如何解决：采用恢复余数算法
判断大小：不管大小关系，都做减法，减后
         如结果为正：说明够减，上1
         如结果为负：说明不够减，上0
得到正确结果，但是：运算次数太多！速度慢
多在：恢复余数上
如何减少运算的次数？
采用不恢复余数算法：
一个二进制数，右移一位得到的值是原来值的1/2
所以：恢复余数，两步变成一步，减少运算次数。
0.9----0.09 右移     0.9----9.0 左移
0.11---0.011
不恢复余数算法口诀：
余数为正，够减，商上1，下一步-y/2
余数为负，不够减，商上0，下一步+y/2
运算5次，又叫加减交替法
减法也是用加法实现的，所以5次都应做加法。
定点数用补码表示
符号单独异或处理
  x=0.1001     y=0.1011   都是正数
  x补=0.1001    y补=0.1011
  y/2=0.01011   y/2补=0.01011
  y/4=0.001011  y/4补=0.001011

  -y=1.1011
  -y补=1.0101
  -y/2=1.01011
  -y/2补=1.10101
  -y/4=1.001011
  -y/4补=1.110101
  补码右移带符号右移

有不恢复余数算法，要构造定点除法器
用n位加法器？不是
只能用全加器（fa）？不是
因为fa只能做ai+bi（xi+yi），只能两个一位相加
除法运算有时：xi+yi  有时  xi+（-yi）
对fa进行改进得到cas（可控加减法运算单元）
基于：
（x-y）补=x补-y补=x补+（-y）补
         =x补+y补取反+1

采用不恢复余数法求除法结果：
：x=0.10110000   y=0.1101
先求出y和-y的补码

如何改进fa得到cas？
fa正常做ai+bi，有三个输入，两个输出
要实现：ai+（-bi）=ai+bi反   +1
改进：1: bi异或后再进入fa
      2:有4个输入，多了一个控制端（p）
      3:有4个输出，p既是输入也是输出
                    bi既是输入也是输出

求：x=0.x1x2x3x4x5x6
    y=0.y1y2y3
求x/y
设：x=0.101101
    y=0.110
    x补=0.101101
    y补=0.110
    -y=1.110
    y补反=1.001+1
    -y补=1.010

0.111011/0.101

浮点运算：
回忆：ieee754标准浮点数由3个部分组成
数符、尾数、阶（用移码表示，+127）
设：x=+2Ex*Mx  y=+2Ey*My
浮点加减运算：求x+y
不能直接尾数相加，因为阶可能不一样
如：0.89*103+0.77*105
两个数的阶不同，所以要先把两个数的阶弄成一样

设：x=+2Ex*Mx  y=+2Ey*My
浮点加减运算：求x+y

浮点加减法过程：
1:求Ex-Ey  是否为0（用定点加法器）
  如为0，说明两个阶相同，可以下一步（加）
  如不为0，说明两个阶不同，要对阶：
  两种对阶方法：
  大阶---小阶转：0.89*103+77.0*103
  尾数左移，丢弃高位，误差大
小阶---大阶转：0.0089*105+0.77*105
尾数右移，丢弃低位，误差小
所以采用小阶---大阶 转换（尾数右移，丢低位）
（用定点加法器）
2:尾数求和（补码表示）（用定点加法器）
  如求的结果不是1.M格式，要通过移位操作变换成该格式左移（阶-1）（用定点加法器）
  如尾数结果溢出了，可以通过右移的方法调整（调整阶+1）（用定点加法器）
3:舍入处理（类似四舍五入）
  右移时丢弃低位，为减小误差，要舍入处理
  0.110101    0.110110（用定点加法器）
4:溢出检测
  浮点数尾数不会溢出（可以右移调整），
 阶可能溢出（32位格式：阶0----254），浮点数溢出

浮点运算其实是用定点加法器实现的。

浮点数乘除法运算：
设：x=+2Ex*Mx  y=+2Ey*My
浮点加减运算：求x*y
x*y=2Ex+Ey*（Mx*My）用定点加法器、定点乘法器
x/y=2Ex-Ey*（Mx/My）用定点加法器、定点除法器
1: 0操作数检查
2:结果规格化（1.M格式）
3:舍入处理
4:溢出检测







第三章：存储器
第二节：半导体存储器
存储器能保存0和1----有两个（只有两个）稳定的状态
一：静态存储器（sram)
存储元电路：能存一个0或者一个1（一位）
三极管：控制端为高电平  a、b 导通
        控制端为低电平  a、b 截止
分析元电路（如何存0或1）
以存1（写1）为例：
1: x线加高电平-----t5、t6导通
  y线加高电平-----t7、t8导通
2:I/O端加高电平（1）
  对应I/O反加低电平（0）
3:I/O（1）  沿着t7、t5到达A点（1）
 I/O反（0）沿着t8、t6到达B点（0）
4: A点（1）连着t2的控制端---t2导通--B点接地（0）
  A点维持B点接地（低电平，0）
  B点（0）连着t1的控制端---t1截止--A不接地（1）
  B点维持A点不接地（高电平，1）
  此时A、B两点的状态稳定下来（1，0）

5: 撤销I/O和I/O反端的1和0
   此时A端的电荷靠vcc提供，一直维持为1
   从而一直维持t2导通，从而一直维持B接地（0），
   从而一直维持t1截止，从而A点一直不接地（1）
   所以：A（1）B（0）
         数据1存在A点
思考：如何写0？
思考：如何读出A点的数据？
思考：x、y线作用？负责将数据通路导通/截止
一个存储元（静态）用到了8管子（先不考虑共用）
类推：
一个字节：要64个管子
一个G的存储器：230个字节约等于
1000*1000*1000*64=640亿个管子（大规模集成电路）

如何用存储元电路构造小容量的存储器？
以一个16位的存储器为例
（假设一个字节4位，4个字节）
用一个方框代表一个存储元电路，要16个方框
这16个存储元如何排列？如何连接？


现在我们要向第二行这个字节写入数据1011
实现：
x2线加高电平，其它x0、x1、x3加低电平
则第二行的4个存储元的t5和t6导通
  其它行的存储元的t5、t6截止

把4根y线（y0--y3）连在一起 ，加高电平
则y0--y3四根线都是高电平，所以16个存储元的
t7、t8全部导通

I/O0、I/O1、I/O2、I/O3加 高、低、高、高 电平
此时第二行存放了1011

如何实现4根x线（x0、x1、x2、x3）一根为高电平，其它三根为低电平（如何实现n根线中一根为高电平，其它所有都为低电平？）：使用地址译码器！

继续，构造更大一点容量的存储器：16个字节
按上述方法，增加12行，共16行，一行一个字节



这种排列方法称为单译码方式（一行一个字节）
此时y线设为高电平，不起选择作用。
    x线选择某行

用一个方框代表一个字节（4位）
单译码方式要16根行选线（x线）+1根列选线（y线）=17根选择线

双译码方式：一行多个字节
比如16个字节，排列成4行，每行4个字节
此时y线起作用
假设要往第二行，第三列字节写入1100
x2线加高电平、y3线加高电平，I/O线加高高低低
双译码方式要4根行选线+4根列选线=8根选择线
双译码方式减少选择线根数

假设1个G字节（230个字节）
采用单译码方式，需要230根行选择线+1根列选线
                =10亿根选择线
采用双译码方式，215行，每行215个字节，
需要215根行选择线+215根列选择线=64000根选择线
所以要采用双译码方式

思考：地址译码器的作用是将cpu发出的
      n位地址，转换成2n根选择线中的一根为1，
      其它线都为0
      比如cpu发出2位地址，经过译码后变成
      4（22）根线的选择信号。
      用门电路设计这样的地址译码器？
1:2译码器   2:4  3:8   5:32  32:4G

A14---A8     A7--A0 （共15位地址）
  列地址     行地址
CPU发出地址
0000011     00000111
问哪个字节被cpu选中？
第三列        第七行

二：动态存储器（dram）（要会和sram对比）
先看动态存储元（存0或1）
利用电容存储数据0或1
电容状态：充电（表示1）  和   放电（表示0）


读1操作存在的问题：破坏性读
电容的电荷读走，等于做了放电操作，
读完后，存储的数据由1变成了0 
如何解决？
和该问题类似：
电容中的电荷即使没有读出，也会随着时间流逝，慢慢泄露，导致1变0的错误
如何解决？
为电容补充电荷：先读出，再判断，再补充
上述过程又称为刷新
简单对比dram（动态）和sram（静态）
集成度：
1个G的dram要80亿个管子
1个G的sram要640亿个管子
sram的集成度高，造价高，价格高，适合做小容量的高速缓存（cache），不用刷新
dram的集成度低，造价低，价格低，适合做大容量的内存，需要刷新（花大量时间刷新，此时cpu无法访问内存，速度慢）



关于刷新：补充电荷
刷新周期：从电容充满电开始，到1--0临界点，所能维持的时间。在一个刷新周期内要刷新所有存储元。
如果以存储元为单位刷新，那么耗时太长。
实际按行刷新，每次刷新一行，速度快
也就是说在一个刷新周期内要刷完所有行。
刷新方式：
集中式刷新：在一个刷新周期内，安排一段时间，
            不做读写操作（cpu不能访问），专门刷新所有行
缺点：cpu较长时间访问不到内存
分散式刷新：把一个正常的读写周期分为两部分，一次正常读写，一次刷新。
优点：死时间短
缺点：刷新次数多
异步式刷新：只要保证在一个刷新周期内刷完所有行，至于某行什么时候开始刷新不固定，可以利用空闲时间（cpu没有读写请求）刷新若干行。
缺点：控制复杂


动态存储器结构（dram存储器）：采用双译码方式
动态存储器容量可以做的很大，------地址位数多
如：
4个字节，地址2位
16个字节的存储器，地址4位
512字节的存储器，地址9位
1个G的存储器，地址30位
地址位数多，引脚多，为了减少引脚数，采用：
行列地址分时传送的方式：比如1个G的内存，行地址15位，列地址15位，地址线（引脚数）只要15根，先传15位行地址，再传15位列地址。
内存如何知道传过来的是行地址还是列地址？
配合行选通信号和列选通信号（开关信号）

刷新地址计数器：能从0开始计数，每次+1
                是循环计数，计数到行数时归0
                每刷新一行+1
                因为是按行刷新的，所以计数器的
                值就是行地址
                采用异步式刷新，在一个刷新周期内，计数器从0到行数-1 过一遍

地址多路开关：
在cpu发出的行地址和刷新计数器的值之间切换。
最终两者之间的一个行地址送存储器，如是cpu发出的行地址，内存正常读写；如是计数器发出的行地址，内存刷新一行。

刷新定时器：（相当于闹钟）每隔一段时间，产生一个刷新信号，表示该刷新一行了

仲裁电路：在刷新信号和读写信号（cpu发出）之间仲裁。仲裁电路信号送定时发生器

分析完sram和dram后，可以构造存储器了，接下来要解决两个问题：如何构造更大容量的存储器？
                如何提高存储器的读写速度？

存储器容量的扩充：大容量的存储器通常由小容量的存储芯片组成。如何扩充？
扩充时要解决：芯片如何连接？通过地址线、数据线、控制线连接。
1:字长位数的扩展：（并）
  总字数不变，字长增加
例题：用两个1M*4位的芯片构造1M*8位的存储器
两个芯片共用cpu发出的地址信号
两个芯片的数据线分别连数据总线的高低4位
两个芯片共用cpu发出的控制总线

2:字数的扩展
例题：用两个1M*8位的芯片构造2M*8位的存储器
             220              221
两个芯片串联：
两个芯片的数据线共用（会不会产生冲突？？）
                       不会冲突，两个芯片每次只有一个工作（被选中）
扩充后的存储器地址21位（A0---A20）
单个芯片的地址20位（A0---A19）
多出来的A20是干嘛的？作为片选信号（选择哪一芯片）
   A0---A20的前20位 （A0---A19）共用，第21位A20作为片选
控制线共用
3:前两种方式的结合
用1K*4位的芯片，构造2K*8位的存储器

第五节：并行存储器（提高存储器的速度）
一：双端口存储器
端口：是地址、数据、控制线的合称，cpu通过端口和存储器连接
双端口存储器：理论上，一次读写周期可以完成两次读写操作
存在有冲突的读写操作：两个端口的地址相同、且存在写操作，此时冲突产生

二：多模块交叉存储器
通过数据存储的顺序，加快读写速度
在一段时间内，cpu访问的数据是连续的
方法1:在单个模块内，数据是连续的，称为顺序方式
方法2:连续的数据分散在不同的模块中，称为交叉方式
假设：cpu要读取连续的0---3四个数据
      读写周期为T
顺序方式：要4T（T+3T）
交叉方式：理论上只要1T
          实际要考虑总线的传送时间t（t<T,t包含在T内的），不止1T，实际为：T+3t
注意：交叉存储方式对模块数有最低要求
要求：同一模块下一次读写时上一次读写操作已经完成
   T=mt（m是模块数）
   m=T/t

第六节：高速缓冲存储器（cache）
正常情况：cpu和内存交换数据,内存采用动态存储方式（DRAM），读写速度远慢于cpu的运算速度。
改进：在cpu和内存之间增加一个小容量的静态存储器（以MB为单位），称为cache
命中率：在一段时间内，cpu从cache访问到数据的概率。我们希望命中率越高越好（接近100%）
程序的局部性原理：在一段时间内，cpu要访问的数据是集中在一起的。假如我们先把这一小部分数据调入cache,保证了在接下来的一段时间内，cpu要访问的数据大部分在cache中。
待解决的问题：
1:从内存过来的数据放在cache什么位置？
2：怎么知道数据在还是不在cache中？
3:当cache满的时候，新的数据如何替换旧的数据？
4：如何保证cache中的数据和内存数据的一致性？
5：命中率如何计算？
命中率：h=Nc÷(Nc+ Nm)
Nc是cpu访问cache的次数
Nm是cpu访问内存的次数
希望h接近1

平均访问时间：ta=htc+(1-h)tm
希望ta接近tc

访问效率：
e=tc/ta=tc/(htc+(1-h)tm)=1/(h+(1-h)r)
设r=tm/tc表示主存慢于cache的倍率
从用户角度希望cache的读写速度越快越好，
但是cache的速度和内存的速度不能相差太大,如果相差太大，访问效率反而降低。以5—10倍为宜。

作业：第九题（下周三交）

内存和cache的地址映射关系：放在cache什么地方
三种映射关系：
一：全相联映射：
假设内存有256行（每行若干列）,cache有8行
为了区分内存和cache，把内存行称为块
内存的某一块数据调入cache，放在哪儿？
全相联：一块数据可以放在cache的任意行
怎么判断数据在不在cache中？
为cache的每一行设置一个标记（？）,其实就是内存的块地址(256块的块地址为8位),某一块调入cache同时，该块的8位块地址也保存在cache中，作为标记。
cpu访问数据要提供块地址,拿该块地址和cache
的标记比较,如果有标记和块地址相同，说明cpu此次要访问的数据就在cache中(命中)；假如所有标记和块地址都不相同，说明此次要访问的数据不在cache中（未命中）
全相联映射为了判断在不在：(比较标记)
要比较最少1次(和cache的第0行标记比较就相等)
      最多8次（和cache的每一行的标记都比较）
全映射缺点：比较次数可能太多;标记长
二：直接映射
内存的一块数据只能放在cache的特定?行
特定行i=块号j   MOD   cache行数m
假设内存有256块（每块若干列）,cache有8行
采用直接映射
比如：第9块 放在 第i=9 MOD 8=1 行
第13块 放在i=13 MOD 8=5行
类推：第0，8，16，24，32，40….放在第0行
判断是否在cache中，比较标记，标记几位？
写出上述块地址的二进制形式：（8位）
00000000
00001000
00010000
00011000
00100000
00101000
….
观察上述几个数，发现它们的低三位都一样：000
既然是一样的，这三位可以不予保存、不予比较。
所以标记位数=8-3=5位（少于全相联映射：8）
直接映射标记只要比较1次
直接映射的缺点：在同一行内会产生冲突
前两种映射方式各有优缺点，可以综合一下
三：组相联映射
将cache分为若干组，每组若干行，组间采用直接映射，组内采用全映射。
假设cache8行，分为4组，每组2行，内存256块

内存的第0，4，8，12，16，20….块放在cache的第0组:块号j   MOD   cache组数4
类推：3，7，11，15..块放在cache的第3组
3： 00000011
7： 00000111
11：00001011
15：00001111
….
上述数字的最低2位都是11，不予保存、不予比较
所以标记位数=8-2=6位
需要比较：最少1次，最多2次

假设内存规格是256行（块），每行（块）128个字
立即得到：块地址8位，列地址7位
Cache有8行
采用全相联映射：标记=8位,字（列）地址7位
采用直接映射：标记=5位，r=3位,字（列）地址7位
采用组映射：标记=6位，组号d=2位,字（列）地址7位



第三次作业：五一之后的周三课后交
1：cache 32行，内存1024块，分别采用全、直接、组映射方式，回答分别：标记几位？比较几次？
分组方式：分为8组，每组4行。
2:用不恢复余数除法计算:
  X=0.101001
  Y=0.110
  求：x/y

Cache的替换策略：
替换：当cache已存有数据，此时新的数据进来，要换掉旧的数据，换哪些？依据是什么？
三种替换策略：
一：最不经常使用(LFU)算法：将一段时间内被访问次数最少的那行数据换出。
如何知道访问次数：为cache的每一行增加一个标记（计数器）,某行每被访问一次，计数器+1，替换时，替换计数器值最小的行。
存在问题：新调入cache的数据可能会很快又被替换出去，因为它的计数器值最小,而新调入的数据很可能是接下来一段时间内cpu要经常访问的数据。
二：近期最少使用(LRU)算法：LRU算法将近期内长久未被访问过的行换出。
为cache的每一行增加一个计数器,某行被访问，该行计数器清0，其它行计数器+1，替换时，替换计数器值大的行。实现了保护新行。
对于2路组相联映射方式的cache来说，可以不用计数器，只要一个一位的标记（cache分组，每组2行）:被访问的行的标记置0，该组的另一行标记置1.替换时替换标记为1的行。
三种映射方式中有一种不需要考虑替换策略：直接映射方式。
三：随机替换：随机替换策略从特定的行位置中随机地选取一行换出。

Cache的写操作策略：（修改操作）
Cache中的数据是从内存调入的，也就是说存放在两个地方的数据实际上是一个数。就要保证它们的值是一致的。如何保证一致？
写回法：cpu写操作在cache中执行，当这部分数据被替换时，再写内存。
保证最终cache中的值和内存中的值是一致的。
缺点：在数据被替换出去前，cache和内存的数据可能是不一致的。不适用于实时性要求高的系统。
怎么知道数据被写（修改）过？
为cache的每行增加一位标记，（0未写，1写过）
全写法 ：当写cache命中时，cache与主存同时发生写修改
始终保证cache和内存中的数据一致。不要判断是否写过。
缺点：写操作时，同时写内存，降低了读写速度。
写一次法：第一次写cache同时写内存，其它写操作采用写回法。
这样做的原因：cpu第一次访问数据时，同时启动访问内存的操作，（防止数据不在cache中）











第五章：中央处理器（cpu）
第一节：cpu的功能和组成
一．	cpu的功能
1.	指令控制：要保证按照程序的顺序执行一条条的指令
指令的地址在哪儿？放在cpu中什么地方？如何执行？
2.	操作控制：将指令的操作码翻译成若干控制信号，由控制信号控制各个部件工作。
指令译码？MOV---1010--？--控制信号
3．时间控制：控制信号的生效在时间上是有先后次序的，cpu能够产生时间信号，并和控制信号叠加。
比如：ADD指令：取操作数1，取操作数2，加，存结果
4．数据加工：能实现算术运算和逻辑运算
二．cpu的基本组成
1：控制器
 取指令、指令译码、时许控制
2：运算器
 算术运算器、逻辑运算器
假设有一个cpu模型，分析该模型的构成
三．	cpu中的主要寄存器
1：通用寄存器R0—R3：为ALU提供操作数
2：数据缓冲寄存器DR：起缓冲作用
3：地址寄存器AR：存放的是操作数在内存的地址
4：程序计数器PC：存放的是指令在内存的地址，具备+1功能
5：指令寄存器IR：存放从内存取来的一条指令，要送指令译码器
6：状态字寄存器PSW：存放一次运算除结果之外的其它状态值
四．	操作控制和时许发生器
各部件之间联系的通路称为数据通路，它有两种状态：导通和截止
操作控制器控制数据通路的导通和截止（？）：通过控制信号控制
叠加时间信号

第二节：指令周期
一．	几个概念
指令周期：从取指令开始到指令执行完毕所需要的时间
一个指令周期分为若干CPU周期
在一个cpu周期内要保证能完成一个完整的操作
选所有操作中耗时最长的那个操作的时间作为一个cpu周期的长度
访问内存的操作耗时最长，所以通常用从内存取一条指令的时间作为一个cpu周期的定义。
考虑：一个指令周期至少包含几个cpu周期？
      2个：取指令、执行指令
一个cpu周期包含若干T周期




分析五条指令的指令周期：
1：MOV R0,R1  将R1寄存器的值送到R0寄存器
第一个cpu周期：取指令cpu周期，是所有指令共同的
1.	当程序装载到内存时，第一条指令的内存地址放在PC中
2.	PC（101）经ABUS(I)送内存
3.	内存取出101单元内容（MOV指令）经IBUS送IR
4.	PC(101)+1变为102，为下一条指令准备
5.	指令译码
6.	取指令完成
第二个cpu周期：执行指令（是否一个cpu周期就够了？）
1：选择R1作为源寄存器，选R0作为目的寄存器
2：R1送ALU，启动ALU做传送操作（两个操作,要两个控制信号）
3：alu值送dbus
4：dbus送dr
5：dr送r0
执行完毕
2：LAD R1,6  把内存6号单元的数取进cpu，放在R1寄存器中
第一个cpu周期：取指令cpu周期
1：pc（102）经abus（i）送内存
2：内存取出lad指令经指令总线ibus送ir
3：pc（102）+1变为103，为下一条指令准备
4：指令译码
第二个cpu周期：执行阶段
1：ir.地址码（6）经dbus送地址寄存器ar
2：ar（6）经abus（d）送内存
—————————————分为两个cpu周期，避免dbus冲突
3：内存取6号单元的数（100）送dbus
4：dbus（100）送dr
5：dr（100）送r1
执行完毕，要几个cpu周期？
一个不够！
分析：因为该cpu内部，数据和地址线共用（dbus）
      一个cpu周期内，总线上只能传一个值
所以上述过程一个cpu周期不够，要分为两个cpu周期
所以lad指令的指令周期包含三个cpu周期（取指令一个，执行两个）
看后三条的指令周期分析。

3:ADD R1,R2指令周期 （R1）+(R2) 和存放在R2中
第一个cpu周期：取指令cpu周期
1：pc（103）经abus（i）送内存
2：内存取出lad指令经指令总线ibus送ir
3：pc（103）+1变为104，为下一条指令准备
4：指令译码
第二个cpu周期：执行指令cpu周期
1：选中r1和r2寄存器
2：启动alu作+运算
3：alu（和）打到dbus上
4：dbus打到dr中
5：dr送r2
执行完毕

4：sto  r2，（r3）
第一个cpu周期：取指令cpu周期
1：pc（104）经abus（i）送内存
2：内存取出lad指令经指令总线ibus送ir
3：pc（104）+1变为105，为下一条指令准备
4：指令译码
第二个cpu周期：执行cpu周期
先送内存地址（30 在 r3寄存器中）
1：选中r3
2：r3（30）送dbus
3：dbus打入ar 送内存
送操作数（120 在 r2 寄存器中）
4：选中r2
5：r2（120）送dbus
6：dbus（120） 送内存
执行完毕，执行阶段一个cpu周期够不够？不够
因为：执行阶段dbus上传送了两个值：30（地址） 、120（数据）
一个cpu周期内，总线上只能传一个值
所以要两个cpu周期
所以sto指令指令周期，包含三个cpu周期

5：jmp 101 ：跳转指令，下一次跳到101位置执行
第一个cpu周期：取指令
1：pc（105）经abus（i）送内存
2：内存取出lad指令经指令总线ibus送ir
3：pc（105）+1变为106，为下一条指令准备
4：指令译码
第二个cpu周期：执行指令（要把pc寄存器的值修改为101）
1：ir.地址码（101）送dbus
2：dbus送pc
执行完毕
作业：先分析and指令的指令周期，再画出方框图，基于图5.1

用方框图表示指令周期
方框：表示一个cpu周期，在方框内写全控制信号
菱形：表示指令译码和测试，不单独占用时间，它依附于前一个方框。
波浪线：表示公操作（一条指令执行完毕后，接下来要做的操作）
        取指令就是一个典型的公操作

例题：图5.15是一个区别于图5.1的新模型

第三节：时序产生器和控制方式
指令译码后产生的控制信号要和时间信号叠加
比如：加法指令（add）
1：选中r1和r2寄存器
2：启动alu作+运算
3：alu（和）打到dbus上
4：dbus打到dr中
5：dr送r2
第5个控制信号应该最后有效，不能提前，如何保证？
时间信号如何产生
第四节：微程序控制器
把cpu内部部件分为控制部件和执行部件
控制部件向执行部件发出的命令称为微命令
执行部件响应微命令完成的操作称为微操作
图5.20中1-9 就是9个微命令、+-M也是微命令
比如：4号微命令：控制r1寄存器值经x端送alu
      6号微命令：控制r2寄存器值经x端送alu
     等等…….
 上述12个微命令有些是可以在一个cpu周期内同时有效的，有一些不行。
比如：4、6、8 就不能在一个cpu周期内同时有效，它们称为相斥性微命令（还有：579  +-M）
比如：1、2、3可以在一个cpu周期内同时有效，它们称为相容性微命令（还有：4和5    6和9 等都是相容的）
这里的微命令其实就是控制信号
把所有的微命令放在一起构成一条微指令，一位对应一个微命令
取值1：表示该微命令有效；
取值0：表示该微命令无效。
图5.21：
第1---12位对应上述12个微命令
思考：10、11、12能不能同时为1？不能，只能一个为1其它两个为0（因为它们是相斥的）
思考：1、2、3能不能同时为1？可以（因为它们是相容的）
13—17也是微命令：
   13：读写内存
   14：数据打入dr
   15：指令打入ir
   16：地址打入ar
   17：pc+1（为下一条指令做准备）
第18---23位：不是微命令，是微地址（顺序控制）
比如ADD指令：
第一个cpu周期：取指令cpu周期
1：pc（103）经abus（i）送内存
2：内存取出lad指令经指令总线ibus送ir
3：pc（103）+1变为104，为下一条指令准备
4：指令译码
第二个cpu周期：执行指令cpu周期
1：选中r1和r2寄存器
2：启动alu作+运算
3：alu（和）打到dbus上
4：dbus打到dr中
5：dr送r2
执行完毕
先看取指令cpu周期：（前17位）对应一条微指令
第13位、15位、16位、17位要为1  其它为0
再看执行指令cpu周期：（前17位）对应一条微指令
第4（r1经x送alu）、7（r2经y送alu）、10（alu+）、2（alu结果打入r2），这4个微命令为1，其它为0，这4个微命令的生效是有时间先后的，2号微命令和t4与，保证2号微命令最后生效。
也就是：ADD指令由两条微指令构成（一个cpu周期对应一条微指令）

这两条微指令分别为：
  前17位                18—23位
00000000000010111        ？？？？？？
01010010010000000        ？？？？？？
上述两条微指令构成的东西称为微程序
也就是说一条指令(如ADD)的实现  是  由一个微程序完成的
                                   微程序由若干条微指令构成
                          微指令由所有微命令构成（和顺序控制）
                            





